{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/alpha-dust/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","path":"img/bg-pattern.png","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/js/main.js","path":"js/main.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Linux_Bootcamp_for_Beginners_-_Session_1.md","hash":"9a1d1df5239ce5baed31e59e70b3d528891f5933","modified":1667413491003},{"_id":"source/_posts/Linux_Bootcamp_for_Beginners_-_Session_2.md","hash":"3ec864a992aa77172fdb20539396e9bc104fdc5d","modified":1667413512509},{"_id":"source/_posts/Linux_Bootcamp_for_Beginners_-_Session_3.md","hash":"a12ddfdb51aa7568db04190892c492d3d01ddf2b","modified":1667413506303},{"_id":"themes/alpha-dust/.gitignore","hash":"2aa039aab52800662710bbf503671c770af96621","modified":1667410955227},{"_id":"themes/alpha-dust/LICENSE","hash":"20fb6ab02264ce4860e25cd70b50fa86c08f1cf8","modified":1667410955227},{"_id":"themes/alpha-dust/README.md","hash":"a45542dc41cb204cae82300daf1216ded96f4a13","modified":1667410955227},{"_id":"themes/alpha-dust/_config.yml","hash":"4e827752e910d942baf0e7544bf832dda5a9b6ac","modified":1667410955227},{"_id":"themes/alpha-dust/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1667410955227},{"_id":"themes/alpha-dust/languages/default.yml","hash":"bc4b0f68c3579f8d9c217b96ae9d2da1991c92f7","modified":1667410955227},{"_id":"themes/alpha-dust/languages/en.yml","hash":"9debce519356b44354cf1a613f8916321e572d7f","modified":1667410955227},{"_id":"themes/alpha-dust/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1667410955227},{"_id":"themes/alpha-dust/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1667410955227},{"_id":"themes/alpha-dust/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1667410955227},{"_id":"themes/alpha-dust/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1667410955227},{"_id":"themes/alpha-dust/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1667410955227},{"_id":"themes/alpha-dust/languages/vi.yml","hash":"e402277d26045d704a8bd9fd195b9bbb905a658c","modified":1667410955227},{"_id":"themes/alpha-dust/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1667410955227},{"_id":"themes/alpha-dust/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1667410955228},{"_id":"themes/alpha-dust/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1667410955228},{"_id":"themes/alpha-dust/layout/index.ejs","hash":"a3f94e4a627a83735b82d93694980e988a32d65e","modified":1667410955228},{"_id":"themes/alpha-dust/layout/archive.ejs","hash":"535ea1205c3dd8782aa8dec64c5bb67a5e118be9","modified":1667410955228},{"_id":"themes/alpha-dust/layout/layout.ejs","hash":"2655449a77b370284e6af41aa72c7d72660008fa","modified":1667410955228},{"_id":"themes/alpha-dust/layout/page.ejs","hash":"8b54e1af70b375b92837885814d26c0629253bc1","modified":1667410955228},{"_id":"themes/alpha-dust/layout/post.ejs","hash":"5e1c76ceea8fb6f770b0592648d7e31ccea21a82","modified":1667410955228},{"_id":"themes/alpha-dust/template/index.html","hash":"8f5f763e912a2f84306e3857b476c5cd1c048cb0","modified":1667410955237},{"_id":"themes/alpha-dust/template/archive.html","hash":"239ef36831f10f892ecdbf4438994d62cc973caa","modified":1667410955229},{"_id":"themes/alpha-dust/template/post.html","hash":"8c586749ca621e6b24c07d792cb28c7827a0ed21","modified":1667410955237},{"_id":"themes/alpha-dust/layout/_partial/after-footer.ejs","hash":"15d1d1376aabe398cce7d18ff4af41635970dd29","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/article-archive.ejs","hash":"460768ed91c4bf71199f01685d7af385354ffd28","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/article-long.ejs","hash":"f2b2d0165cb35e30c9764c324e530f487e7de59e","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/article-short.ejs","hash":"792602a61177c8059ef27efd695532f456c8ca84","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/comments.ejs","hash":"423529d88d45e0a928f6cfadcf9aef27ccb63c13","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/footer.ejs","hash":"cc7cbd208e1f7f2e961953f28f5e6c6bb34b5302","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/footer_categories.ejs","hash":"1831ae75b1deb1729e858b2cd83e32fff3a33f6f","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/footer_recent_posts.ejs","hash":"569addbbc7d548fca4986e09631489f8515280ff","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/gallery.ejs","hash":"80c3758b90fe6c197b52602456e2c4dcf7167847","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/head.ejs","hash":"68f2f08fef4763ffaaf1d890084e7a8ba7f86e3f","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/header.ejs","hash":"c189a234d36c6b5c51f814007d5d779bf42f0191","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/menu.ejs","hash":"452e31aa3016cdf9febfe5c2597a335417873f08","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/pagination.ejs","hash":"b9ec572a16d79cba2341211d7623cd04d2b6e521","modified":1667410955228},{"_id":"themes/alpha-dust/layout/_partial/tag-cat-item.ejs","hash":"62e78d4f9cccaa1f32121309498596d6b4c5f0ad","modified":1667410955228},{"_id":"themes/alpha-dust/source/css/style.styl","hash":"47e8e5969922a74d0df6f3e8686b538a22db04ae","modified":1667410955229},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1667410955229},{"_id":"themes/alpha-dust/source/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1667410955229},{"_id":"themes/alpha-dust/template/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1667410955229},{"_id":"themes/alpha-dust/template/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1667410955229},{"_id":"themes/alpha-dust/template/css/style.css","hash":"50bf62012aa42d76e71ef6c6d359e0c6b02f1f41","modified":1667410955229},{"_id":"themes/alpha-dust/template/css/style.styl","hash":"792ff84e3a2b75cbdc216c8b37089eff0c4ec6bc","modified":1667410955229},{"_id":"themes/alpha-dust/template/img/bg-pattern copy.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1667410955236},{"_id":"themes/alpha-dust/template/img/bg-pattern-blue.png","hash":"07016986a35c5bfc04c1599829d6a4798c966731","modified":1667410955236},{"_id":"themes/alpha-dust/template/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1667410955236},{"_id":"themes/alpha-dust/template/img/hex-bg.png","hash":"a8444a553dd0fd7db09eda830bd3346cc87fc60e","modified":1667410955237},{"_id":"themes/alpha-dust/template/js/main.js","hash":"656d203e231f4533d97654816ff285fcbdfd0956","modified":1667410955237},{"_id":"themes/alpha-dust/source/css/_partial/archive.styl","hash":"77f7b4341cb8d12191035150de6bb04635eb2a89","modified":1667410955228},{"_id":"themes/alpha-dust/source/css/_partial/base.styl","hash":"f01047771a92520cf318930331517f4c9e70c04a","modified":1667410955228},{"_id":"themes/alpha-dust/source/css/_partial/code.styl","hash":"3d2bbfef131c2f3fc5d44f54597da850ce29e2cf","modified":1667410955228},{"_id":"themes/alpha-dust/source/css/_partial/footer.styl","hash":"0a086dfb77bc55b27378f97e442e3a696f69048f","modified":1667410955228},{"_id":"themes/alpha-dust/source/css/_partial/header.styl","hash":"2e1e2ab562719127c7e216a49f8d7c02f9a0c2c4","modified":1667410955228},{"_id":"themes/alpha-dust/source/css/_partial/menu.styl","hash":"746c0bc7b37096b5f0f0a451c4783a054b22c309","modified":1667410955228},{"_id":"themes/alpha-dust/source/css/_partial/pagination.styl","hash":"2368cc9bd2404bce950b55fb2d9be3e7f1e1039c","modified":1667410955229},{"_id":"themes/alpha-dust/source/css/_partial/post-content.styl","hash":"117b655a4f0c78b3cb3fb7be3e09b829c1debc49","modified":1667410955229},{"_id":"themes/alpha-dust/source/css/_partial/post-layout.styl","hash":"b60fbbd78ca88d2174db1426cf941b6c998dd823","modified":1667410955229},{"_id":"themes/alpha-dust/source/css/_partial/variables.styl","hash":"789108805cf6d536b8a979a722b5b26a7e27fb28","modified":1667410955229},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1667410955236},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1667410955236},{"_id":"themes/alpha-dust/template/img/session_image.jpeg","hash":"5a3669c0564044f56cb7cea464119a8e388fb18f","modified":1667410955237},{"_id":"themes/alpha-dust/template/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1667410955231},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1667410955232},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1667410955236},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1667410955234},{"_id":"public/2022/11/02/Linux_Bootcamp_for_Beginners_-_Session_1/index.html","hash":"9f3aaa6fb4bf1ffb433d1d3a9ae9eab2fb58e855","modified":1667413545254},{"_id":"public/archives/index.html","hash":"d4dfc6570a3b6a66de695a584a437a64ed62cc53","modified":1667413545254},{"_id":"public/archives/2022/index.html","hash":"e352ceae4d2663826f42eeae32d77bd6d6a7f85f","modified":1667413545254},{"_id":"public/archives/2022/11/index.html","hash":"ff26e4cd114dbd642f93a1935a5032b5d15f029a","modified":1667413545254},{"_id":"public/2022/11/02/Linux_Bootcamp_for_Beginners_-_Session_3/index.html","hash":"7e82d20c45be6dcbff7254ab82ebc9f74fcb1a4c","modified":1667413545254},{"_id":"public/2022/11/02/Linux_Bootcamp_for_Beginners_-_Session_2/index.html","hash":"98831e5690590c044b608174fcd7db83b6ae9675","modified":1667413545254},{"_id":"public/index.html","hash":"6396640a76b8374736842256488e04d75c29c65a","modified":1667413545254},{"_id":"public/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1667413545254},{"_id":"public/css/style.css","hash":"a8b4312a0a6e600e3c1629df20e2860757370d10","modified":1667413545254},{"_id":"public/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1667413545254}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Linux Bootcamp for Beginners - Session 1","_content":"\n# What is Linux?\n- **Linux** is a family of open source operating systems (OS) which is modelled based on UNIX.\n- It was created by **Linus Trovalds** , first released on **September 17,1991**.\n- Linux is typically packaged in a Linux Distribution (aka Distro) like **Ubuntu, Fedora , Arch Linux etc**\n- Besides being the **platform** of choice to run desktops, servers,mobile phones and embedded systems across the globe, Linux is one of the most **reliable, secure and adaptable** operating systems available\n# Meet the Mascot\n![Tux the penguin](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/150px-Tux.svg.png)\n\n- **Tux** is the official mascot and and brand character of Linux.\n- Also used to represent **Linux Devs**  and as general symbol for Linux\n\n\n# Free and Open Source (FOSS)\n\n**Open source follows these key tenants :** \n\n\n- The freedom to run the program, for any purpose.\n- The freedom to study how the program works, and change it to make it do what you wish.\n- The freedom to redistribute copies so you can help your neighbor.\n- The freedom to distribute copies of your modified versions to others.\n\nBasically you can do anything with that software!\n\n\n","source":"_posts/Linux_Bootcamp_for_Beginners_-_Session_1.md","raw":"---\ntitle: Linux Bootcamp for Beginners - Session 1\n---\n\n# What is Linux?\n- **Linux** is a family of open source operating systems (OS) which is modelled based on UNIX.\n- It was created by **Linus Trovalds** , first released on **September 17,1991**.\n- Linux is typically packaged in a Linux Distribution (aka Distro) like **Ubuntu, Fedora , Arch Linux etc**\n- Besides being the **platform** of choice to run desktops, servers,mobile phones and embedded systems across the globe, Linux is one of the most **reliable, secure and adaptable** operating systems available\n# Meet the Mascot\n![Tux the penguin](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/150px-Tux.svg.png)\n\n- **Tux** is the official mascot and and brand character of Linux.\n- Also used to represent **Linux Devs**  and as general symbol for Linux\n\n\n# Free and Open Source (FOSS)\n\n**Open source follows these key tenants :** \n\n\n- The freedom to run the program, for any purpose.\n- The freedom to study how the program works, and change it to make it do what you wish.\n- The freedom to redistribute copies so you can help your neighbor.\n- The freedom to distribute copies of your modified versions to others.\n\nBasically you can do anything with that software!\n\n\n","slug":"Linux_Bootcamp_for_Beginners_-_Session_1","published":1,"date":"2022-11-02T18:23:41.051Z","updated":"2022-11-02T18:24:51.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zyz1sq00007ilmfath786m","content":"<h1 id=\"What-is-Linux\"><a href=\"#What-is-Linux\" class=\"headerlink\" title=\"What is Linux?\"></a>What is Linux?</h1><ul>\n<li><strong>Linux</strong> is a family of open source operating systems (OS) which is modelled based on UNIX.</li>\n<li>It was created by <strong>Linus Trovalds</strong> , first released on <strong>September 17,1991</strong>.</li>\n<li>Linux is typically packaged in a Linux Distribution (aka Distro) like <strong>Ubuntu, Fedora , Arch Linux etc</strong></li>\n<li>Besides being the <strong>platform</strong> of choice to run desktops, servers,mobile phones and embedded systems across the globe, Linux is one of the most <strong>reliable, secure and adaptable</strong> operating systems available</li>\n</ul>\n<h1 id=\"Meet-the-Mascot\"><a href=\"#Meet-the-Mascot\" class=\"headerlink\" title=\"Meet the Mascot\"></a>Meet the Mascot</h1><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/150px-Tux.svg.png\" alt=\"Tux the penguin\"></p>\n<ul>\n<li><strong>Tux</strong> is the official mascot and and brand character of Linux.</li>\n<li>Also used to represent <strong>Linux Devs</strong>  and as general symbol for Linux</li>\n</ul>\n<h1 id=\"Free-and-Open-Source-FOSS\"><a href=\"#Free-and-Open-Source-FOSS\" class=\"headerlink\" title=\"Free and Open Source (FOSS)\"></a>Free and Open Source (FOSS)</h1><p><strong>Open source follows these key tenants :</strong> </p>\n<ul>\n<li>The freedom to run the program, for any purpose.</li>\n<li>The freedom to study how the program works, and change it to make it do what you wish.</li>\n<li>The freedom to redistribute copies so you can help your neighbor.</li>\n<li>The freedom to distribute copies of your modified versions to others.</li>\n</ul>\n<p>Basically you can do anything with that software!</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"What-is-Linux\"><a href=\"#What-is-Linux\" class=\"headerlink\" title=\"What is Linux?\"></a>What is Linux?</h1><ul>\n<li><strong>Linux</strong> is a family of open source operating systems (OS) which is modelled based on UNIX.</li>\n<li>It was created by <strong>Linus Trovalds</strong> , first released on <strong>September 17,1991</strong>.</li>\n<li>Linux is typically packaged in a Linux Distribution (aka Distro) like <strong>Ubuntu, Fedora , Arch Linux etc</strong></li>\n<li>Besides being the <strong>platform</strong> of choice to run desktops, servers,mobile phones and embedded systems across the globe, Linux is one of the most <strong>reliable, secure and adaptable</strong> operating systems available</li>\n</ul>\n<h1 id=\"Meet-the-Mascot\"><a href=\"#Meet-the-Mascot\" class=\"headerlink\" title=\"Meet the Mascot\"></a>Meet the Mascot</h1><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/150px-Tux.svg.png\" alt=\"Tux the penguin\"></p>\n<ul>\n<li><strong>Tux</strong> is the official mascot and and brand character of Linux.</li>\n<li>Also used to represent <strong>Linux Devs</strong>  and as general symbol for Linux</li>\n</ul>\n<h1 id=\"Free-and-Open-Source-FOSS\"><a href=\"#Free-and-Open-Source-FOSS\" class=\"headerlink\" title=\"Free and Open Source (FOSS)\"></a>Free and Open Source (FOSS)</h1><p><strong>Open source follows these key tenants :</strong> </p>\n<ul>\n<li>The freedom to run the program, for any purpose.</li>\n<li>The freedom to study how the program works, and change it to make it do what you wish.</li>\n<li>The freedom to redistribute copies so you can help your neighbor.</li>\n<li>The freedom to distribute copies of your modified versions to others.</li>\n</ul>\n<p>Basically you can do anything with that software!</p>\n"},{"title":"Linux Bootcamp for Beginners - Session 2","_content":"\n# Linus Torvalds\n![Linus Torvalds](https://upload.wikimedia.org/wikipedia/commons/e/e8/Lc3_2018_%28263682303%29_%28cropped%29.jpeg)\n\n\n\n# Storage Structure of Linux\n![](https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654032263623_mermaid-diagram-20220601025416.png)\n\n\n\n- In Linux, the file system creates a tree structure. All the files are arranged as a tree and its branches. \n- The topmost directory called the **root (/) directory**. All other directories in Linux can be accessed from the root directory.\n- Some Features in Linux include :- \n    - **Specifying paths:** Linux does not use the backslash (\\) to separate the components; it uses forward slash (/) as an alternative. \n    - **Partition, Directories, and Drives:** Linux does not use drive letters to organize the drive as Windows does. In Linux, we cannot tell whether we are addressing a partition, a network device, or an \"ordinary\" directory and a Drive.\n    - **Case Sensitivity:** Linux file system is case sensitive. It distinguishes between lowercase and uppercase file names. This is also followed in **Linux commands** \n    - **File Extensions:** In Linux, a file may have the extension '.txt,' but it is not necessary that a file should have a file extension. If we use the graphical file manager, it symbolizes the files and folders.\n    - **Hidden files:** Linux distinguishes between standard files and hidden files, mostly the configuration files are hidden in Linux OS. Usually, we don't need to access or read the hidden files. The hidden files in Linux are represented by a dot (.) before the file name (e.g., .ignore). To access the files, we need to change the view in the file manager or need to use a specific command in the shell.\n# Linux File Permissions\n\nThe basic Linux permissions model works by associating each system file with an owner and a group and assigning permission access rights for three different classes of users:\n\n## **Permission Groups**\n    - **owner** – The Owner permissions apply only to the owner of the file or directory, they will not impact the actions of other users.\n    - **group** – The Group permissions apply only to the group that has been assigned to the file or directory, they will not affect the actions of other users.\n    - **all users** – The All Users permissions apply to all other users on the system, this is the permission group that you want to watch the most.\n    \n\n**Permission Types**\nThree file permissions types apply to each class of users:\n\n- The `read` permission.\n- The `write` permission.\n- The `execute` permission.\n| permission  | on a file                | on a directory                   |\n| ----------- | ------------------------ | -------------------------------- |\n| r (read)    | read file content (cat)  | read directory content (ls)      |\n| w (write)   | change file content (vi) | create file in directory (touch) |\n| x (execute) | execute the file         | enter the directory (cd)         |\n\n\n\n# Basic I/O\n\n\n    echo \"Hello Everyone\"\n# Linux Terminal\n- The Linux terminal is a text-based interface used to control a Linux computer.\n- It's just one of the many tools provided to Linux users for accomplishing any given task, but it's widely considered the most efficient method available.\n- It's so popular, in fact, that Apple changed its foundation to Unix and has gained the `bash` and `zsh`\n- Microsoft developed PowerShell, its very own open source command line similiar to Linux Terminals\n# Linux Commands\n- A **command** is a special keyword you can use in a terminal to tell your computer to perform an action.\n- Most commands are tiny little applications that get installed with the rest of your operating system ( Even applications like `cat`, `ls` , `curl` )\n## Arguments in Linux Commands\n- An **argument** is any part of a command that isn't the command\n- It directs the command to do a particular task\n\n**Example**\n\n    ls Documents\n## Options in Linux Commands\n- Command **options**, also called **flags** or **switches**, are part of command arguments. \n- A command argument is anything that follows a command, and an option is usually (but not always) demarcated by a dash or double dashes.\n\n**Example**\n\n    python3 --version\n\n\n# Pipelining in Linux\n- A `pipeline` is a sequence of one or more commands separated by one of the control operators ‘|’ or ‘|&’.\n- The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command’s output.\n- `grep` is used to search for patterns or particular word in a list.\n\n`grep` \n\n    cat <file> | grep <something>\n\n**Example**\n\n    ls -l | grep sample\n![](https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654029159937_mermaid-diagram-20220601002450.png)\n\n# Redirections in Terminal\n- **Input/Output (I/O) redirection** in Linux refers to the ability of the Linux operating system that allows us to change the standard input (`stdin`) and standard output (`stdout`) when executing a command on the terminal.\n- By default, the standard input device is your keyboard and the standard output device is your screen.\n\n**Types of Redirection** \n\n**1. Overwrite**  \nIt completely overwrites with new data. Any old data present will be lost.\n\n\n- `>` standard output\n- `<` standard input\n\n**2. Appends**  \n\nIt appends to the existing/old data. Any old data present will not be lost.\n\n- `>>` standard output\n- `<<` standard input\n\n**Error Redirection:** Error redirection is transferring the errors generated by some false commands to a file rather than STDOUT.\n\n\n    gcc 2>error.txt\n\n\n    cat error.txt\n    gcc: fatal error: no input files\n    compilation terminated.\n\n\n# Linux Shell\n- The shell is the **Linux command line interpreter**. It provides an interface between the user and the kernel and executes programs called commands.\n- Shell is an environment in which we can run our programs, and shell scripts.\n## Types of shell \n- Friendly Interactive Shell - `fish`\n- POSIX shell - `sh`\n- Bourne Again shell - `bash`\n- Z Shell `zsh` \n\nBy Default Ubuntu has `bash` pre-installed\n\n## Shell Scripting \n- A shell script is a computer program designed to be run by the Unix shell(here bash), a command-line interpreter. \n- Every shell script starts with a shebang construct to alert the system that a shell script has been started. For example :\n\n\n    #!/bin/sh\n\n**Comments** \n\n- Single Line comments - `#`\n- Multi Line comments - `: '` to open and `'` to close.\n\n**Example** \n\n\n    #!/bin/bash\n    \n    # Author : Adarsh Liju Abraham\n\n\n- `echo` is used to print any string to `stdout`\n- `read` is used to accept data from `stdin`\n\n**Example**\n\n    #!/bin/bash\n    \n    # Author : Adarsh Liju Abraham\n    \n    \n\n\n","source":"_posts/Linux_Bootcamp_for_Beginners_-_Session_2.md","raw":"---\ntitle: Linux Bootcamp for Beginners - Session 2\n---\n\n# Linus Torvalds\n![Linus Torvalds](https://upload.wikimedia.org/wikipedia/commons/e/e8/Lc3_2018_%28263682303%29_%28cropped%29.jpeg)\n\n\n\n# Storage Structure of Linux\n![](https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654032263623_mermaid-diagram-20220601025416.png)\n\n\n\n- In Linux, the file system creates a tree structure. All the files are arranged as a tree and its branches. \n- The topmost directory called the **root (/) directory**. All other directories in Linux can be accessed from the root directory.\n- Some Features in Linux include :- \n    - **Specifying paths:** Linux does not use the backslash (\\) to separate the components; it uses forward slash (/) as an alternative. \n    - **Partition, Directories, and Drives:** Linux does not use drive letters to organize the drive as Windows does. In Linux, we cannot tell whether we are addressing a partition, a network device, or an \"ordinary\" directory and a Drive.\n    - **Case Sensitivity:** Linux file system is case sensitive. It distinguishes between lowercase and uppercase file names. This is also followed in **Linux commands** \n    - **File Extensions:** In Linux, a file may have the extension '.txt,' but it is not necessary that a file should have a file extension. If we use the graphical file manager, it symbolizes the files and folders.\n    - **Hidden files:** Linux distinguishes between standard files and hidden files, mostly the configuration files are hidden in Linux OS. Usually, we don't need to access or read the hidden files. The hidden files in Linux are represented by a dot (.) before the file name (e.g., .ignore). To access the files, we need to change the view in the file manager or need to use a specific command in the shell.\n# Linux File Permissions\n\nThe basic Linux permissions model works by associating each system file with an owner and a group and assigning permission access rights for three different classes of users:\n\n## **Permission Groups**\n    - **owner** – The Owner permissions apply only to the owner of the file or directory, they will not impact the actions of other users.\n    - **group** – The Group permissions apply only to the group that has been assigned to the file or directory, they will not affect the actions of other users.\n    - **all users** – The All Users permissions apply to all other users on the system, this is the permission group that you want to watch the most.\n    \n\n**Permission Types**\nThree file permissions types apply to each class of users:\n\n- The `read` permission.\n- The `write` permission.\n- The `execute` permission.\n| permission  | on a file                | on a directory                   |\n| ----------- | ------------------------ | -------------------------------- |\n| r (read)    | read file content (cat)  | read directory content (ls)      |\n| w (write)   | change file content (vi) | create file in directory (touch) |\n| x (execute) | execute the file         | enter the directory (cd)         |\n\n\n\n# Basic I/O\n\n\n    echo \"Hello Everyone\"\n# Linux Terminal\n- The Linux terminal is a text-based interface used to control a Linux computer.\n- It's just one of the many tools provided to Linux users for accomplishing any given task, but it's widely considered the most efficient method available.\n- It's so popular, in fact, that Apple changed its foundation to Unix and has gained the `bash` and `zsh`\n- Microsoft developed PowerShell, its very own open source command line similiar to Linux Terminals\n# Linux Commands\n- A **command** is a special keyword you can use in a terminal to tell your computer to perform an action.\n- Most commands are tiny little applications that get installed with the rest of your operating system ( Even applications like `cat`, `ls` , `curl` )\n## Arguments in Linux Commands\n- An **argument** is any part of a command that isn't the command\n- It directs the command to do a particular task\n\n**Example**\n\n    ls Documents\n## Options in Linux Commands\n- Command **options**, also called **flags** or **switches**, are part of command arguments. \n- A command argument is anything that follows a command, and an option is usually (but not always) demarcated by a dash or double dashes.\n\n**Example**\n\n    python3 --version\n\n\n# Pipelining in Linux\n- A `pipeline` is a sequence of one or more commands separated by one of the control operators ‘|’ or ‘|&’.\n- The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command’s output.\n- `grep` is used to search for patterns or particular word in a list.\n\n`grep` \n\n    cat <file> | grep <something>\n\n**Example**\n\n    ls -l | grep sample\n![](https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654029159937_mermaid-diagram-20220601002450.png)\n\n# Redirections in Terminal\n- **Input/Output (I/O) redirection** in Linux refers to the ability of the Linux operating system that allows us to change the standard input (`stdin`) and standard output (`stdout`) when executing a command on the terminal.\n- By default, the standard input device is your keyboard and the standard output device is your screen.\n\n**Types of Redirection** \n\n**1. Overwrite**  \nIt completely overwrites with new data. Any old data present will be lost.\n\n\n- `>` standard output\n- `<` standard input\n\n**2. Appends**  \n\nIt appends to the existing/old data. Any old data present will not be lost.\n\n- `>>` standard output\n- `<<` standard input\n\n**Error Redirection:** Error redirection is transferring the errors generated by some false commands to a file rather than STDOUT.\n\n\n    gcc 2>error.txt\n\n\n    cat error.txt\n    gcc: fatal error: no input files\n    compilation terminated.\n\n\n# Linux Shell\n- The shell is the **Linux command line interpreter**. It provides an interface between the user and the kernel and executes programs called commands.\n- Shell is an environment in which we can run our programs, and shell scripts.\n## Types of shell \n- Friendly Interactive Shell - `fish`\n- POSIX shell - `sh`\n- Bourne Again shell - `bash`\n- Z Shell `zsh` \n\nBy Default Ubuntu has `bash` pre-installed\n\n## Shell Scripting \n- A shell script is a computer program designed to be run by the Unix shell(here bash), a command-line interpreter. \n- Every shell script starts with a shebang construct to alert the system that a shell script has been started. For example :\n\n\n    #!/bin/sh\n\n**Comments** \n\n- Single Line comments - `#`\n- Multi Line comments - `: '` to open and `'` to close.\n\n**Example** \n\n\n    #!/bin/bash\n    \n    # Author : Adarsh Liju Abraham\n\n\n- `echo` is used to print any string to `stdout`\n- `read` is used to accept data from `stdin`\n\n**Example**\n\n    #!/bin/bash\n    \n    # Author : Adarsh Liju Abraham\n    \n    \n\n\n","slug":"Linux_Bootcamp_for_Beginners_-_Session_2","published":1,"date":"2022-11-02T18:23:41.091Z","updated":"2022-11-02T18:25:12.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zyz1sv00017ilm6pe32bki","content":"<h1 id=\"Linus-Torvalds\"><a href=\"#Linus-Torvalds\" class=\"headerlink\" title=\"Linus Torvalds\"></a>Linus Torvalds</h1><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e8/Lc3_2018_%28263682303%29_%28cropped%29.jpeg\" alt=\"Linus Torvalds\"></p>\n<h1 id=\"Storage-Structure-of-Linux\"><a href=\"#Storage-Structure-of-Linux\" class=\"headerlink\" title=\"Storage Structure of Linux\"></a>Storage Structure of Linux</h1><p><img src=\"https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654032263623_mermaid-diagram-20220601025416.png\"></p>\n<ul>\n<li>In Linux, the file system creates a tree structure. All the files are arranged as a tree and its branches. </li>\n<li>The topmost directory called the <strong>root (&#x2F;) directory</strong>. All other directories in Linux can be accessed from the root directory.</li>\n<li>Some Features in Linux include :- <ul>\n<li><strong>Specifying paths:</strong> Linux does not use the backslash () to separate the components; it uses forward slash (&#x2F;) as an alternative. </li>\n<li><strong>Partition, Directories, and Drives:</strong> Linux does not use drive letters to organize the drive as Windows does. In Linux, we cannot tell whether we are addressing a partition, a network device, or an “ordinary” directory and a Drive.</li>\n<li><strong>Case Sensitivity:</strong> Linux file system is case sensitive. It distinguishes between lowercase and uppercase file names. This is also followed in <strong>Linux commands</strong> </li>\n<li><strong>File Extensions:</strong> In Linux, a file may have the extension ‘.txt,’ but it is not necessary that a file should have a file extension. If we use the graphical file manager, it symbolizes the files and folders.</li>\n<li><strong>Hidden files:</strong> Linux distinguishes between standard files and hidden files, mostly the configuration files are hidden in Linux OS. Usually, we don’t need to access or read the hidden files. The hidden files in Linux are represented by a dot (.) before the file name (e.g., .ignore). To access the files, we need to change the view in the file manager or need to use a specific command in the shell.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Linux-File-Permissions\"><a href=\"#Linux-File-Permissions\" class=\"headerlink\" title=\"Linux File Permissions\"></a>Linux File Permissions</h1><p>The basic Linux permissions model works by associating each system file with an owner and a group and assigning permission access rights for three different classes of users:</p>\n<h2 id=\"Permission-Groups\"><a href=\"#Permission-Groups\" class=\"headerlink\" title=\"Permission Groups\"></a><strong>Permission Groups</strong></h2><pre><code>- **owner** – The Owner permissions apply only to the owner of the file or directory, they will not impact the actions of other users.\n- **group** – The Group permissions apply only to the group that has been assigned to the file or directory, they will not affect the actions of other users.\n- **all users** – The All Users permissions apply to all other users on the system, this is the permission group that you want to watch the most.\n</code></pre>\n<p><strong>Permission Types</strong><br>Three file permissions types apply to each class of users:</p>\n<ul>\n<li>The <code>read</code> permission.</li>\n<li>The <code>write</code> permission.</li>\n<li>The <code>execute</code> permission.<table>\n<thead>\n<tr>\n<th>permission</th>\n<th>on a file</th>\n<th>on a directory</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r (read)</td>\n<td>read file content (cat)</td>\n<td>read directory content (ls)</td>\n</tr>\n<tr>\n<td>w (write)</td>\n<td>change file content (vi)</td>\n<td>create file in directory (touch)</td>\n</tr>\n<tr>\n<td>x (execute)</td>\n<td>execute the file</td>\n<td>enter the directory (cd)</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h1 id=\"Basic-I-x2F-O\"><a href=\"#Basic-I-x2F-O\" class=\"headerlink\" title=\"Basic I&#x2F;O\"></a>Basic I&#x2F;O</h1><pre><code>echo &quot;Hello Everyone&quot;\n</code></pre>\n<h1 id=\"Linux-Terminal\"><a href=\"#Linux-Terminal\" class=\"headerlink\" title=\"Linux Terminal\"></a>Linux Terminal</h1><ul>\n<li>The Linux terminal is a text-based interface used to control a Linux computer.</li>\n<li>It’s just one of the many tools provided to Linux users for accomplishing any given task, but it’s widely considered the most efficient method available.</li>\n<li>It’s so popular, in fact, that Apple changed its foundation to Unix and has gained the <code>bash</code> and <code>zsh</code></li>\n<li>Microsoft developed PowerShell, its very own open source command line similiar to Linux Terminals</li>\n</ul>\n<h1 id=\"Linux-Commands\"><a href=\"#Linux-Commands\" class=\"headerlink\" title=\"Linux Commands\"></a>Linux Commands</h1><ul>\n<li>A <strong>command</strong> is a special keyword you can use in a terminal to tell your computer to perform an action.</li>\n<li>Most commands are tiny little applications that get installed with the rest of your operating system ( Even applications like <code>cat</code>, <code>ls</code> , <code>curl</code> )</li>\n</ul>\n<h2 id=\"Arguments-in-Linux-Commands\"><a href=\"#Arguments-in-Linux-Commands\" class=\"headerlink\" title=\"Arguments in Linux Commands\"></a>Arguments in Linux Commands</h2><ul>\n<li>An <strong>argument</strong> is any part of a command that isn’t the command</li>\n<li>It directs the command to do a particular task</li>\n</ul>\n<p><strong>Example</strong></p>\n<pre><code>ls Documents\n</code></pre>\n<h2 id=\"Options-in-Linux-Commands\"><a href=\"#Options-in-Linux-Commands\" class=\"headerlink\" title=\"Options in Linux Commands\"></a>Options in Linux Commands</h2><ul>\n<li>Command <strong>options</strong>, also called <strong>flags</strong> or <strong>switches</strong>, are part of command arguments. </li>\n<li>A command argument is anything that follows a command, and an option is usually (but not always) demarcated by a dash or double dashes.</li>\n</ul>\n<p><strong>Example</strong></p>\n<pre><code>python3 --version\n</code></pre>\n<h1 id=\"Pipelining-in-Linux\"><a href=\"#Pipelining-in-Linux\" class=\"headerlink\" title=\"Pipelining in Linux\"></a>Pipelining in Linux</h1><ul>\n<li>A <code>pipeline</code> is a sequence of one or more commands separated by one of the control operators ‘|’ or ‘|&amp;’.</li>\n<li>The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command’s output.</li>\n<li><code>grep</code> is used to search for patterns or particular word in a list.</li>\n</ul>\n<p><code>grep</code> </p>\n<pre><code>cat &lt;file&gt; | grep &lt;something&gt;\n</code></pre>\n<p><strong>Example</strong></p>\n<pre><code>ls -l | grep sample\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654029159937_mermaid-diagram-20220601002450.png\"></p>\n<h1 id=\"Redirections-in-Terminal\"><a href=\"#Redirections-in-Terminal\" class=\"headerlink\" title=\"Redirections in Terminal\"></a>Redirections in Terminal</h1><ul>\n<li><strong>Input&#x2F;Output (I&#x2F;O) redirection</strong> in Linux refers to the ability of the Linux operating system that allows us to change the standard input (<code>stdin</code>) and standard output (<code>stdout</code>) when executing a command on the terminal.</li>\n<li>By default, the standard input device is your keyboard and the standard output device is your screen.</li>\n</ul>\n<p><strong>Types of Redirection</strong> </p>\n<p><strong>1. Overwrite</strong><br>It completely overwrites with new data. Any old data present will be lost.</p>\n<ul>\n<li><code>&gt;</code> standard output</li>\n<li><code>&lt;</code> standard input</li>\n</ul>\n<p><strong>2. Appends</strong>  </p>\n<p>It appends to the existing&#x2F;old data. Any old data present will not be lost.</p>\n<ul>\n<li><code>&gt;&gt;</code> standard output</li>\n<li><code>&lt;&lt;</code> standard input</li>\n</ul>\n<p><strong>Error Redirection:</strong> Error redirection is transferring the errors generated by some false commands to a file rather than STDOUT.</p>\n<pre><code>gcc 2&gt;error.txt\n\n\ncat error.txt\ngcc: fatal error: no input files\ncompilation terminated.\n</code></pre>\n<h1 id=\"Linux-Shell\"><a href=\"#Linux-Shell\" class=\"headerlink\" title=\"Linux Shell\"></a>Linux Shell</h1><ul>\n<li>The shell is the <strong>Linux command line interpreter</strong>. It provides an interface between the user and the kernel and executes programs called commands.</li>\n<li>Shell is an environment in which we can run our programs, and shell scripts.</li>\n</ul>\n<h2 id=\"Types-of-shell\"><a href=\"#Types-of-shell\" class=\"headerlink\" title=\"Types of shell\"></a>Types of shell</h2><ul>\n<li>Friendly Interactive Shell - <code>fish</code></li>\n<li>POSIX shell - <code>sh</code></li>\n<li>Bourne Again shell - <code>bash</code></li>\n<li>Z Shell <code>zsh</code></li>\n</ul>\n<p>By Default Ubuntu has <code>bash</code> pre-installed</p>\n<h2 id=\"Shell-Scripting\"><a href=\"#Shell-Scripting\" class=\"headerlink\" title=\"Shell Scripting\"></a>Shell Scripting</h2><ul>\n<li><p>A shell script is a computer program designed to be run by the Unix shell(here bash), a command-line interpreter. </p>\n</li>\n<li><p>Every shell script starts with a shebang construct to alert the system that a shell script has been started. For example :</p>\n<p>  #!&#x2F;bin&#x2F;sh</p>\n</li>\n</ul>\n<p><strong>Comments</strong> </p>\n<ul>\n<li>Single Line comments - <code>#</code></li>\n<li>Multi Line comments - <code>: &#39;</code> to open and <code>&#39;</code> to close.</li>\n</ul>\n<p><strong>Example</strong> </p>\n<pre><code>#!/bin/bash\n\n# Author : Adarsh Liju Abraham\n</code></pre>\n<ul>\n<li><code>echo</code> is used to print any string to <code>stdout</code></li>\n<li><code>read</code> is used to accept data from <code>stdin</code></li>\n</ul>\n<p><strong>Example</strong></p>\n<pre><code>#!/bin/bash\n\n# Author : Adarsh Liju Abraham\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linus-Torvalds\"><a href=\"#Linus-Torvalds\" class=\"headerlink\" title=\"Linus Torvalds\"></a>Linus Torvalds</h1><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e8/Lc3_2018_%28263682303%29_%28cropped%29.jpeg\" alt=\"Linus Torvalds\"></p>\n<h1 id=\"Storage-Structure-of-Linux\"><a href=\"#Storage-Structure-of-Linux\" class=\"headerlink\" title=\"Storage Structure of Linux\"></a>Storage Structure of Linux</h1><p><img src=\"https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654032263623_mermaid-diagram-20220601025416.png\"></p>\n<ul>\n<li>In Linux, the file system creates a tree structure. All the files are arranged as a tree and its branches. </li>\n<li>The topmost directory called the <strong>root (&#x2F;) directory</strong>. All other directories in Linux can be accessed from the root directory.</li>\n<li>Some Features in Linux include :- <ul>\n<li><strong>Specifying paths:</strong> Linux does not use the backslash () to separate the components; it uses forward slash (&#x2F;) as an alternative. </li>\n<li><strong>Partition, Directories, and Drives:</strong> Linux does not use drive letters to organize the drive as Windows does. In Linux, we cannot tell whether we are addressing a partition, a network device, or an “ordinary” directory and a Drive.</li>\n<li><strong>Case Sensitivity:</strong> Linux file system is case sensitive. It distinguishes between lowercase and uppercase file names. This is also followed in <strong>Linux commands</strong> </li>\n<li><strong>File Extensions:</strong> In Linux, a file may have the extension ‘.txt,’ but it is not necessary that a file should have a file extension. If we use the graphical file manager, it symbolizes the files and folders.</li>\n<li><strong>Hidden files:</strong> Linux distinguishes between standard files and hidden files, mostly the configuration files are hidden in Linux OS. Usually, we don’t need to access or read the hidden files. The hidden files in Linux are represented by a dot (.) before the file name (e.g., .ignore). To access the files, we need to change the view in the file manager or need to use a specific command in the shell.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Linux-File-Permissions\"><a href=\"#Linux-File-Permissions\" class=\"headerlink\" title=\"Linux File Permissions\"></a>Linux File Permissions</h1><p>The basic Linux permissions model works by associating each system file with an owner and a group and assigning permission access rights for three different classes of users:</p>\n<h2 id=\"Permission-Groups\"><a href=\"#Permission-Groups\" class=\"headerlink\" title=\"Permission Groups\"></a><strong>Permission Groups</strong></h2><pre><code>- **owner** – The Owner permissions apply only to the owner of the file or directory, they will not impact the actions of other users.\n- **group** – The Group permissions apply only to the group that has been assigned to the file or directory, they will not affect the actions of other users.\n- **all users** – The All Users permissions apply to all other users on the system, this is the permission group that you want to watch the most.\n</code></pre>\n<p><strong>Permission Types</strong><br>Three file permissions types apply to each class of users:</p>\n<ul>\n<li>The <code>read</code> permission.</li>\n<li>The <code>write</code> permission.</li>\n<li>The <code>execute</code> permission.<table>\n<thead>\n<tr>\n<th>permission</th>\n<th>on a file</th>\n<th>on a directory</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r (read)</td>\n<td>read file content (cat)</td>\n<td>read directory content (ls)</td>\n</tr>\n<tr>\n<td>w (write)</td>\n<td>change file content (vi)</td>\n<td>create file in directory (touch)</td>\n</tr>\n<tr>\n<td>x (execute)</td>\n<td>execute the file</td>\n<td>enter the directory (cd)</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h1 id=\"Basic-I-x2F-O\"><a href=\"#Basic-I-x2F-O\" class=\"headerlink\" title=\"Basic I&#x2F;O\"></a>Basic I&#x2F;O</h1><pre><code>echo &quot;Hello Everyone&quot;\n</code></pre>\n<h1 id=\"Linux-Terminal\"><a href=\"#Linux-Terminal\" class=\"headerlink\" title=\"Linux Terminal\"></a>Linux Terminal</h1><ul>\n<li>The Linux terminal is a text-based interface used to control a Linux computer.</li>\n<li>It’s just one of the many tools provided to Linux users for accomplishing any given task, but it’s widely considered the most efficient method available.</li>\n<li>It’s so popular, in fact, that Apple changed its foundation to Unix and has gained the <code>bash</code> and <code>zsh</code></li>\n<li>Microsoft developed PowerShell, its very own open source command line similiar to Linux Terminals</li>\n</ul>\n<h1 id=\"Linux-Commands\"><a href=\"#Linux-Commands\" class=\"headerlink\" title=\"Linux Commands\"></a>Linux Commands</h1><ul>\n<li>A <strong>command</strong> is a special keyword you can use in a terminal to tell your computer to perform an action.</li>\n<li>Most commands are tiny little applications that get installed with the rest of your operating system ( Even applications like <code>cat</code>, <code>ls</code> , <code>curl</code> )</li>\n</ul>\n<h2 id=\"Arguments-in-Linux-Commands\"><a href=\"#Arguments-in-Linux-Commands\" class=\"headerlink\" title=\"Arguments in Linux Commands\"></a>Arguments in Linux Commands</h2><ul>\n<li>An <strong>argument</strong> is any part of a command that isn’t the command</li>\n<li>It directs the command to do a particular task</li>\n</ul>\n<p><strong>Example</strong></p>\n<pre><code>ls Documents\n</code></pre>\n<h2 id=\"Options-in-Linux-Commands\"><a href=\"#Options-in-Linux-Commands\" class=\"headerlink\" title=\"Options in Linux Commands\"></a>Options in Linux Commands</h2><ul>\n<li>Command <strong>options</strong>, also called <strong>flags</strong> or <strong>switches</strong>, are part of command arguments. </li>\n<li>A command argument is anything that follows a command, and an option is usually (but not always) demarcated by a dash or double dashes.</li>\n</ul>\n<p><strong>Example</strong></p>\n<pre><code>python3 --version\n</code></pre>\n<h1 id=\"Pipelining-in-Linux\"><a href=\"#Pipelining-in-Linux\" class=\"headerlink\" title=\"Pipelining in Linux\"></a>Pipelining in Linux</h1><ul>\n<li>A <code>pipeline</code> is a sequence of one or more commands separated by one of the control operators ‘|’ or ‘|&amp;’.</li>\n<li>The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command’s output.</li>\n<li><code>grep</code> is used to search for patterns or particular word in a list.</li>\n</ul>\n<p><code>grep</code> </p>\n<pre><code>cat &lt;file&gt; | grep &lt;something&gt;\n</code></pre>\n<p><strong>Example</strong></p>\n<pre><code>ls -l | grep sample\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_C3F2B19DDBDA0B884AC8A93FEFEB05F933EDFD5E6DDAC52F8195936FA757710F_1654029159937_mermaid-diagram-20220601002450.png\"></p>\n<h1 id=\"Redirections-in-Terminal\"><a href=\"#Redirections-in-Terminal\" class=\"headerlink\" title=\"Redirections in Terminal\"></a>Redirections in Terminal</h1><ul>\n<li><strong>Input&#x2F;Output (I&#x2F;O) redirection</strong> in Linux refers to the ability of the Linux operating system that allows us to change the standard input (<code>stdin</code>) and standard output (<code>stdout</code>) when executing a command on the terminal.</li>\n<li>By default, the standard input device is your keyboard and the standard output device is your screen.</li>\n</ul>\n<p><strong>Types of Redirection</strong> </p>\n<p><strong>1. Overwrite</strong><br>It completely overwrites with new data. Any old data present will be lost.</p>\n<ul>\n<li><code>&gt;</code> standard output</li>\n<li><code>&lt;</code> standard input</li>\n</ul>\n<p><strong>2. Appends</strong>  </p>\n<p>It appends to the existing&#x2F;old data. Any old data present will not be lost.</p>\n<ul>\n<li><code>&gt;&gt;</code> standard output</li>\n<li><code>&lt;&lt;</code> standard input</li>\n</ul>\n<p><strong>Error Redirection:</strong> Error redirection is transferring the errors generated by some false commands to a file rather than STDOUT.</p>\n<pre><code>gcc 2&gt;error.txt\n\n\ncat error.txt\ngcc: fatal error: no input files\ncompilation terminated.\n</code></pre>\n<h1 id=\"Linux-Shell\"><a href=\"#Linux-Shell\" class=\"headerlink\" title=\"Linux Shell\"></a>Linux Shell</h1><ul>\n<li>The shell is the <strong>Linux command line interpreter</strong>. It provides an interface between the user and the kernel and executes programs called commands.</li>\n<li>Shell is an environment in which we can run our programs, and shell scripts.</li>\n</ul>\n<h2 id=\"Types-of-shell\"><a href=\"#Types-of-shell\" class=\"headerlink\" title=\"Types of shell\"></a>Types of shell</h2><ul>\n<li>Friendly Interactive Shell - <code>fish</code></li>\n<li>POSIX shell - <code>sh</code></li>\n<li>Bourne Again shell - <code>bash</code></li>\n<li>Z Shell <code>zsh</code></li>\n</ul>\n<p>By Default Ubuntu has <code>bash</code> pre-installed</p>\n<h2 id=\"Shell-Scripting\"><a href=\"#Shell-Scripting\" class=\"headerlink\" title=\"Shell Scripting\"></a>Shell Scripting</h2><ul>\n<li><p>A shell script is a computer program designed to be run by the Unix shell(here bash), a command-line interpreter. </p>\n</li>\n<li><p>Every shell script starts with a shebang construct to alert the system that a shell script has been started. For example :</p>\n<p>  #!&#x2F;bin&#x2F;sh</p>\n</li>\n</ul>\n<p><strong>Comments</strong> </p>\n<ul>\n<li>Single Line comments - <code>#</code></li>\n<li>Multi Line comments - <code>: &#39;</code> to open and <code>&#39;</code> to close.</li>\n</ul>\n<p><strong>Example</strong> </p>\n<pre><code>#!/bin/bash\n\n# Author : Adarsh Liju Abraham\n</code></pre>\n<ul>\n<li><code>echo</code> is used to print any string to <code>stdout</code></li>\n<li><code>read</code> is used to accept data from <code>stdin</code></li>\n</ul>\n<p><strong>Example</strong></p>\n<pre><code>#!/bin/bash\n\n# Author : Adarsh Liju Abraham\n</code></pre>\n"},{"title":"Linux Bootcamp for Beginners - Session 3","_content":"# FOSS\n![Richard Stallman](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201183185_371px-Richard_Stallman_at_LibrePlanet_2019.jpg)\n\n## “Free and Open Source Software”\n- The freedom to run the program as you wish, for any purpose .\n- The freedom to study how the program works, and change it so it does your computing as you wish . \n- The freedom to redistribute copies so you can help others.\n- The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this\n\n\n# GNU - GNU’s Not Unix\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201894183_file.png)\n\n\n\n# FOSS vs Proprietary software?\n\nPropreitery soft.\n\n- Costly\n- Under control of the org\n- ppl cant contribute\n\n\n# Process\n\nA program/command when executed, a special instance is provided by the system to the process. This instance consists of all the services/resources that may be utilized by the process under execution. \n\n- Whenever a command is issued in Unix/Linux, it creates/starts a new process. For example, pwd when issued which is used to list the current directory location the user is in, a process starts.\n- Through a 5 digit ID number Unix/Linux keeps an account of the processes, this number is call process ID or PID. Each process in the system has a unique PID.\n- Used up pid’s can be used in again for a newer process since all the possible combinations are used.\n- At any point of time, no two processes with the same pid exist in the system because it is the pid that Unix uses to track each process.\n\n**Foreground Process :** Every process when started runs in foreground by default, receives input from the keyboard, and sends output to the screen.  \n\n**Background Process:** It runs in the background without keyboard input and waits till keyboard input is required. Thus, other processes can be done in parallel with the process running in the background since they do not have to wait for the previous process to be completed. \n\n# Types of process\n\n\n# Parent Process\n\nAll the processes in operating system are created when a process executes the fork() system call except the startup process. The process that used the fork() system call is the parent process. In other words, a parent process is one that creates a child process. A parent process may have multiple child processes but a child process only one parent process.\nOn the success of a fork() system call, the PID of the child process is returned to the parent process and 0 is returned to the child process. On the failure of a fork() system call, -1 is returned to the parent process and a child process is not created.\n\n\n# Child Process\n\nA child process is a process created by a parent process in operating system using a fork() system call. A child process may also be called a subprocess or a subtask.\nA child process is created as its parent process’s copy and inherits most of its attributes. If a child process has no parent process, it was created directly by the kernel.\nIf a child process exits or is interrupted, then a SIGCHLD signal is send to the parent process.\nA diagram that demonstrates parent and child process is given as follows −\n\n![How parent-child process works](http://www.it.uu.se/education/course/homepage/os/vt18/images/module-2/fork-wait-exit.png)\n\n\n\n# Zombie Process\n\nA zombie process is a process whose execution is completed but it still has an entry in the process table. Zombie processes usually occur for child processes, as the parent process still needs to read its child’s exit status. Once this is done using the wait system call, the zombie process is eliminated from the process table. This is known as reaping the zombie process.\n\n![Zombie Process](https://www.tutorialspoint.com/assets/questions/media/12233/Zombie%20Process%20in%20LInux.png)\n\n- All the memory and resources allocated to a process are deallocated when the process terminates using the `exit()` system call. But the process’s entry in the process table is still available. This process is now a zombie process.\n- The exit status of the zombie process zombie process can be read by the parent process using the `wait()` system call. After that, the zombie process is removed from the system. Then the process ID and the process table entry of the zombie process can be reused.\n- If the parent process does not use the `wait()` system call, the zombie process is left in the process table. This creates a resource leak.\n- If the parent process is not running anymore, then the presence of a zombie process indicates an operating system bug. This may not be a serious problem if there are a few zombie processes but under heavier loads, this can create issues for the system such as running out of process table entries.\n- The zombie processes can be removed from the system by sending the `SIGCHLD` signal to the parent, using the kill command. If the zombie process is still not eliminated from the process table by the parent process, then the parent process is terminated if that is acceptable.\n\nWe can see zombie processes if we type `ps -aux`.\n\n| **STAT** | **Process State**                                                     |\n| -------- | --------------------------------------------------------------------- |\n| **D**    | uninterruptible sleep (usually IO)                                    |\n| **R**    | running or runnable (on run queue)                                    |\n| **S**    | interruptible sleep (waiting for an event to complete)                |\n| **T**    | stopped, either by a job control signal or because it is being traced |\n| **X**    | dead (should never be seen)                                           |\n| **Z**    | defunct (\"zombie\") process, terminated but not reaped by its parent   |\n| **<**    | high-priority (not nice to other users)                               |\n| **N**    | low-priority (nice to other users)                                    |\n| **L**    | has pages locked into memory (for real-time and custom IO)            |\n| **s**    | is a session leader                                                   |\n| **l**    | is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)         |\n| **+**    | is in the foreground process group                                    |\n\n\n\n# Orphan Process\n- Orphan processes are those processes that are still running even though their parent process has terminated or finished. A process can be orphaned intentionally or unintentionally.\n- An intentionally orphaned process runs in the background without any manual support. This is usually done to start an indefinitely running service or to complete a long-running job without user attention.\n- An unintentionally orphaned process is created when its parent process crashes or terminates. Unintentional orphan processes can be avoided using the process group mechanism.\n\n\n# Daemon Process\n\nA daemon process is a background process that is not under the direct control of the user. This process is usually started when the system is started and is terminated with the system shut down.\nUsually the parent process of the daemon process is the init process. This is because the init process usually adopts the daemon process after the parent process forks the daemon process and terminates.\nThe daemon process names normally end with a d. Some of the examples of daemon processes in Unix are −\n\n- **crond**\n- This is a job scheduler that runs jobs in the background.\n- **syslogd**\n- This is the system logger that implements the system logging facility and collects system messages.\n- **httpd**\n- This is the web server daemon process that handles the Hypertext Transfer Protocol.\n- **dhcpd**\n- This daemon configures the TCP/IP information for users dynamically.\n# ps\n\nps (Process status) can be used to see/list all the running processes. \n\nNormal Use:\n\n    ps\n\nFor More Info\n\n    ps -f\n\nFor a particular process ID\n\n    ps <process id>\n\n\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654185800241_image.png)\n\n\n**Fields described by ps are described as:** \n\n- **UID**: User ID that this process belongs to (the person running it)\n- **PID**: Process ID\n- **PPID**: Parent process ID (the ID of the process that started it)\n- **C**: CPU utilization of process\n- **STIME**: Process start time\n- **TTY**: Terminal type associated with the process\n- **TIME**: CPU time is taken by the process\n- **CMD**: The command that started this process \n# kill\n- `kill` command in Linux, is a built-in command which is used to terminate processes manually.\n- It helps in unwanted congestion or saturation of tasks.\n\n**Basic Syntax**\n\n    kill <signal> <process id>\n\n`**kill -l**` **:**To display all the available signals\n\n\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654186317333_image.png)\n\n## Usage\n    kill -5 1234\n    kill -SIGKILL 1234\n\n\n# `top`\n- Displays all tasks presently running.\n- It has a CLI for killing, sorting and suspending tasks\n- `htop` is an improved version of this software.\n\n**Usage**\n\n\n    top\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202140380_image.png)\n\n    htop\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202325247_image.png)\n\n\n`**bashtop**`\n\n- bashtop is a resource monitor that shows usage and stats for processor,memory, disks, network and processes.\n    - Easy to use, with a game inspired menu system.\n    -  Function for showing detailed stats for selected process.\n    -  Ability to filter processes.\n    - Easy switching between sorting options.\n    -  Send SIGTERM, SIGKILL, SIGINT to selected process.\n    - UI menu for changing all config file options.\n    - Auto scaling graph for network usage.\n\n\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654706380412_image.png)\n\n\n","source":"_posts/Linux_Bootcamp_for_Beginners_-_Session_3.md","raw":"---\ntitle: Linux Bootcamp for Beginners - Session 3\n---\n# FOSS\n![Richard Stallman](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201183185_371px-Richard_Stallman_at_LibrePlanet_2019.jpg)\n\n## “Free and Open Source Software”\n- The freedom to run the program as you wish, for any purpose .\n- The freedom to study how the program works, and change it so it does your computing as you wish . \n- The freedom to redistribute copies so you can help others.\n- The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this\n\n\n# GNU - GNU’s Not Unix\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201894183_file.png)\n\n\n\n# FOSS vs Proprietary software?\n\nPropreitery soft.\n\n- Costly\n- Under control of the org\n- ppl cant contribute\n\n\n# Process\n\nA program/command when executed, a special instance is provided by the system to the process. This instance consists of all the services/resources that may be utilized by the process under execution. \n\n- Whenever a command is issued in Unix/Linux, it creates/starts a new process. For example, pwd when issued which is used to list the current directory location the user is in, a process starts.\n- Through a 5 digit ID number Unix/Linux keeps an account of the processes, this number is call process ID or PID. Each process in the system has a unique PID.\n- Used up pid’s can be used in again for a newer process since all the possible combinations are used.\n- At any point of time, no two processes with the same pid exist in the system because it is the pid that Unix uses to track each process.\n\n**Foreground Process :** Every process when started runs in foreground by default, receives input from the keyboard, and sends output to the screen.  \n\n**Background Process:** It runs in the background without keyboard input and waits till keyboard input is required. Thus, other processes can be done in parallel with the process running in the background since they do not have to wait for the previous process to be completed. \n\n# Types of process\n\n\n# Parent Process\n\nAll the processes in operating system are created when a process executes the fork() system call except the startup process. The process that used the fork() system call is the parent process. In other words, a parent process is one that creates a child process. A parent process may have multiple child processes but a child process only one parent process.\nOn the success of a fork() system call, the PID of the child process is returned to the parent process and 0 is returned to the child process. On the failure of a fork() system call, -1 is returned to the parent process and a child process is not created.\n\n\n# Child Process\n\nA child process is a process created by a parent process in operating system using a fork() system call. A child process may also be called a subprocess or a subtask.\nA child process is created as its parent process’s copy and inherits most of its attributes. If a child process has no parent process, it was created directly by the kernel.\nIf a child process exits or is interrupted, then a SIGCHLD signal is send to the parent process.\nA diagram that demonstrates parent and child process is given as follows −\n\n![How parent-child process works](http://www.it.uu.se/education/course/homepage/os/vt18/images/module-2/fork-wait-exit.png)\n\n\n\n# Zombie Process\n\nA zombie process is a process whose execution is completed but it still has an entry in the process table. Zombie processes usually occur for child processes, as the parent process still needs to read its child’s exit status. Once this is done using the wait system call, the zombie process is eliminated from the process table. This is known as reaping the zombie process.\n\n![Zombie Process](https://www.tutorialspoint.com/assets/questions/media/12233/Zombie%20Process%20in%20LInux.png)\n\n- All the memory and resources allocated to a process are deallocated when the process terminates using the `exit()` system call. But the process’s entry in the process table is still available. This process is now a zombie process.\n- The exit status of the zombie process zombie process can be read by the parent process using the `wait()` system call. After that, the zombie process is removed from the system. Then the process ID and the process table entry of the zombie process can be reused.\n- If the parent process does not use the `wait()` system call, the zombie process is left in the process table. This creates a resource leak.\n- If the parent process is not running anymore, then the presence of a zombie process indicates an operating system bug. This may not be a serious problem if there are a few zombie processes but under heavier loads, this can create issues for the system such as running out of process table entries.\n- The zombie processes can be removed from the system by sending the `SIGCHLD` signal to the parent, using the kill command. If the zombie process is still not eliminated from the process table by the parent process, then the parent process is terminated if that is acceptable.\n\nWe can see zombie processes if we type `ps -aux`.\n\n| **STAT** | **Process State**                                                     |\n| -------- | --------------------------------------------------------------------- |\n| **D**    | uninterruptible sleep (usually IO)                                    |\n| **R**    | running or runnable (on run queue)                                    |\n| **S**    | interruptible sleep (waiting for an event to complete)                |\n| **T**    | stopped, either by a job control signal or because it is being traced |\n| **X**    | dead (should never be seen)                                           |\n| **Z**    | defunct (\"zombie\") process, terminated but not reaped by its parent   |\n| **<**    | high-priority (not nice to other users)                               |\n| **N**    | low-priority (nice to other users)                                    |\n| **L**    | has pages locked into memory (for real-time and custom IO)            |\n| **s**    | is a session leader                                                   |\n| **l**    | is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)         |\n| **+**    | is in the foreground process group                                    |\n\n\n\n# Orphan Process\n- Orphan processes are those processes that are still running even though their parent process has terminated or finished. A process can be orphaned intentionally or unintentionally.\n- An intentionally orphaned process runs in the background without any manual support. This is usually done to start an indefinitely running service or to complete a long-running job without user attention.\n- An unintentionally orphaned process is created when its parent process crashes or terminates. Unintentional orphan processes can be avoided using the process group mechanism.\n\n\n# Daemon Process\n\nA daemon process is a background process that is not under the direct control of the user. This process is usually started when the system is started and is terminated with the system shut down.\nUsually the parent process of the daemon process is the init process. This is because the init process usually adopts the daemon process after the parent process forks the daemon process and terminates.\nThe daemon process names normally end with a d. Some of the examples of daemon processes in Unix are −\n\n- **crond**\n- This is a job scheduler that runs jobs in the background.\n- **syslogd**\n- This is the system logger that implements the system logging facility and collects system messages.\n- **httpd**\n- This is the web server daemon process that handles the Hypertext Transfer Protocol.\n- **dhcpd**\n- This daemon configures the TCP/IP information for users dynamically.\n# ps\n\nps (Process status) can be used to see/list all the running processes. \n\nNormal Use:\n\n    ps\n\nFor More Info\n\n    ps -f\n\nFor a particular process ID\n\n    ps <process id>\n\n\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654185800241_image.png)\n\n\n**Fields described by ps are described as:** \n\n- **UID**: User ID that this process belongs to (the person running it)\n- **PID**: Process ID\n- **PPID**: Parent process ID (the ID of the process that started it)\n- **C**: CPU utilization of process\n- **STIME**: Process start time\n- **TTY**: Terminal type associated with the process\n- **TIME**: CPU time is taken by the process\n- **CMD**: The command that started this process \n# kill\n- `kill` command in Linux, is a built-in command which is used to terminate processes manually.\n- It helps in unwanted congestion or saturation of tasks.\n\n**Basic Syntax**\n\n    kill <signal> <process id>\n\n`**kill -l**` **:**To display all the available signals\n\n\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654186317333_image.png)\n\n## Usage\n    kill -5 1234\n    kill -SIGKILL 1234\n\n\n# `top`\n- Displays all tasks presently running.\n- It has a CLI for killing, sorting and suspending tasks\n- `htop` is an improved version of this software.\n\n**Usage**\n\n\n    top\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202140380_image.png)\n\n    htop\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202325247_image.png)\n\n\n`**bashtop**`\n\n- bashtop is a resource monitor that shows usage and stats for processor,memory, disks, network and processes.\n    - Easy to use, with a game inspired menu system.\n    -  Function for showing detailed stats for selected process.\n    -  Ability to filter processes.\n    - Easy switching between sorting options.\n    -  Send SIGTERM, SIGKILL, SIGINT to selected process.\n    - UI menu for changing all config file options.\n    - Auto scaling graph for network usage.\n\n\n![](https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654706380412_image.png)\n\n\n","slug":"Linux_Bootcamp_for_Beginners_-_Session_3","published":1,"date":"2022-11-02T18:23:41.121Z","updated":"2022-11-02T18:25:06.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zyz1sx00027ilm29xqev0x","content":"<h1 id=\"FOSS\"><a href=\"#FOSS\" class=\"headerlink\" title=\"FOSS\"></a>FOSS</h1><p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201183185_371px-Richard_Stallman_at_LibrePlanet_2019.jpg\" alt=\"Richard Stallman\"></p>\n<h2 id=\"“Free-and-Open-Source-Software”\"><a href=\"#“Free-and-Open-Source-Software”\" class=\"headerlink\" title=\"“Free and Open Source Software”\"></a>“Free and Open Source Software”</h2><ul>\n<li>The freedom to run the program as you wish, for any purpose .</li>\n<li>The freedom to study how the program works, and change it so it does your computing as you wish . </li>\n<li>The freedom to redistribute copies so you can help others.</li>\n<li>The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this</li>\n</ul>\n<h1 id=\"GNU-GNU’s-Not-Unix\"><a href=\"#GNU-GNU’s-Not-Unix\" class=\"headerlink\" title=\"GNU - GNU’s Not Unix\"></a>GNU - GNU’s Not Unix</h1><p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201894183_file.png\"></p>\n<h1 id=\"FOSS-vs-Proprietary-software\"><a href=\"#FOSS-vs-Proprietary-software\" class=\"headerlink\" title=\"FOSS vs Proprietary software?\"></a>FOSS vs Proprietary software?</h1><p>Propreitery soft.</p>\n<ul>\n<li>Costly</li>\n<li>Under control of the org</li>\n<li>ppl cant contribute</li>\n</ul>\n<h1 id=\"Process\"><a href=\"#Process\" class=\"headerlink\" title=\"Process\"></a>Process</h1><p>A program&#x2F;command when executed, a special instance is provided by the system to the process. This instance consists of all the services&#x2F;resources that may be utilized by the process under execution. </p>\n<ul>\n<li>Whenever a command is issued in Unix&#x2F;Linux, it creates&#x2F;starts a new process. For example, pwd when issued which is used to list the current directory location the user is in, a process starts.</li>\n<li>Through a 5 digit ID number Unix&#x2F;Linux keeps an account of the processes, this number is call process ID or PID. Each process in the system has a unique PID.</li>\n<li>Used up pid’s can be used in again for a newer process since all the possible combinations are used.</li>\n<li>At any point of time, no two processes with the same pid exist in the system because it is the pid that Unix uses to track each process.</li>\n</ul>\n<p><strong>Foreground Process :</strong> Every process when started runs in foreground by default, receives input from the keyboard, and sends output to the screen.  </p>\n<p><strong>Background Process:</strong> It runs in the background without keyboard input and waits till keyboard input is required. Thus, other processes can be done in parallel with the process running in the background since they do not have to wait for the previous process to be completed. </p>\n<h1 id=\"Types-of-process\"><a href=\"#Types-of-process\" class=\"headerlink\" title=\"Types of process\"></a>Types of process</h1><h1 id=\"Parent-Process\"><a href=\"#Parent-Process\" class=\"headerlink\" title=\"Parent Process\"></a>Parent Process</h1><p>All the processes in operating system are created when a process executes the fork() system call except the startup process. The process that used the fork() system call is the parent process. In other words, a parent process is one that creates a child process. A parent process may have multiple child processes but a child process only one parent process.<br>On the success of a fork() system call, the PID of the child process is returned to the parent process and 0 is returned to the child process. On the failure of a fork() system call, -1 is returned to the parent process and a child process is not created.</p>\n<h1 id=\"Child-Process\"><a href=\"#Child-Process\" class=\"headerlink\" title=\"Child Process\"></a>Child Process</h1><p>A child process is a process created by a parent process in operating system using a fork() system call. A child process may also be called a subprocess or a subtask.<br>A child process is created as its parent process’s copy and inherits most of its attributes. If a child process has no parent process, it was created directly by the kernel.<br>If a child process exits or is interrupted, then a SIGCHLD signal is send to the parent process.<br>A diagram that demonstrates parent and child process is given as follows −</p>\n<p><img src=\"http://www.it.uu.se/education/course/homepage/os/vt18/images/module-2/fork-wait-exit.png\" alt=\"How parent-child process works\"></p>\n<h1 id=\"Zombie-Process\"><a href=\"#Zombie-Process\" class=\"headerlink\" title=\"Zombie Process\"></a>Zombie Process</h1><p>A zombie process is a process whose execution is completed but it still has an entry in the process table. Zombie processes usually occur for child processes, as the parent process still needs to read its child’s exit status. Once this is done using the wait system call, the zombie process is eliminated from the process table. This is known as reaping the zombie process.</p>\n<p><img src=\"https://www.tutorialspoint.com/assets/questions/media/12233/Zombie%20Process%20in%20LInux.png\" alt=\"Zombie Process\"></p>\n<ul>\n<li>All the memory and resources allocated to a process are deallocated when the process terminates using the <code>exit()</code> system call. But the process’s entry in the process table is still available. This process is now a zombie process.</li>\n<li>The exit status of the zombie process zombie process can be read by the parent process using the <code>wait()</code> system call. After that, the zombie process is removed from the system. Then the process ID and the process table entry of the zombie process can be reused.</li>\n<li>If the parent process does not use the <code>wait()</code> system call, the zombie process is left in the process table. This creates a resource leak.</li>\n<li>If the parent process is not running anymore, then the presence of a zombie process indicates an operating system bug. This may not be a serious problem if there are a few zombie processes but under heavier loads, this can create issues for the system such as running out of process table entries.</li>\n<li>The zombie processes can be removed from the system by sending the <code>SIGCHLD</code> signal to the parent, using the kill command. If the zombie process is still not eliminated from the process table by the parent process, then the parent process is terminated if that is acceptable.</li>\n</ul>\n<p>We can see zombie processes if we type <code>ps -aux</code>.</p>\n<table>\n<thead>\n<tr>\n<th><strong>STAT</strong></th>\n<th><strong>Process State</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>D</strong></td>\n<td>uninterruptible sleep (usually IO)</td>\n</tr>\n<tr>\n<td><strong>R</strong></td>\n<td>running or runnable (on run queue)</td>\n</tr>\n<tr>\n<td><strong>S</strong></td>\n<td>interruptible sleep (waiting for an event to complete)</td>\n</tr>\n<tr>\n<td><strong>T</strong></td>\n<td>stopped, either by a job control signal or because it is being traced</td>\n</tr>\n<tr>\n<td><strong>X</strong></td>\n<td>dead (should never be seen)</td>\n</tr>\n<tr>\n<td><strong>Z</strong></td>\n<td>defunct (“zombie”) process, terminated but not reaped by its parent</td>\n</tr>\n<tr>\n<td><strong>&lt;</strong></td>\n<td>high-priority (not nice to other users)</td>\n</tr>\n<tr>\n<td><strong>N</strong></td>\n<td>low-priority (nice to other users)</td>\n</tr>\n<tr>\n<td><strong>L</strong></td>\n<td>has pages locked into memory (for real-time and custom IO)</td>\n</tr>\n<tr>\n<td><strong>s</strong></td>\n<td>is a session leader</td>\n</tr>\n<tr>\n<td><strong>l</strong></td>\n<td>is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</td>\n</tr>\n<tr>\n<td><strong>+</strong></td>\n<td>is in the foreground process group</td>\n</tr>\n</tbody></table>\n<h1 id=\"Orphan-Process\"><a href=\"#Orphan-Process\" class=\"headerlink\" title=\"Orphan Process\"></a>Orphan Process</h1><ul>\n<li>Orphan processes are those processes that are still running even though their parent process has terminated or finished. A process can be orphaned intentionally or unintentionally.</li>\n<li>An intentionally orphaned process runs in the background without any manual support. This is usually done to start an indefinitely running service or to complete a long-running job without user attention.</li>\n<li>An unintentionally orphaned process is created when its parent process crashes or terminates. Unintentional orphan processes can be avoided using the process group mechanism.</li>\n</ul>\n<h1 id=\"Daemon-Process\"><a href=\"#Daemon-Process\" class=\"headerlink\" title=\"Daemon Process\"></a>Daemon Process</h1><p>A daemon process is a background process that is not under the direct control of the user. This process is usually started when the system is started and is terminated with the system shut down.<br>Usually the parent process of the daemon process is the init process. This is because the init process usually adopts the daemon process after the parent process forks the daemon process and terminates.<br>The daemon process names normally end with a d. Some of the examples of daemon processes in Unix are −</p>\n<ul>\n<li><strong>crond</strong></li>\n<li>This is a job scheduler that runs jobs in the background.</li>\n<li><strong>syslogd</strong></li>\n<li>This is the system logger that implements the system logging facility and collects system messages.</li>\n<li><strong>httpd</strong></li>\n<li>This is the web server daemon process that handles the Hypertext Transfer Protocol.</li>\n<li><strong>dhcpd</strong></li>\n<li>This daemon configures the TCP&#x2F;IP information for users dynamically.</li>\n</ul>\n<h1 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h1><p>ps (Process status) can be used to see&#x2F;list all the running processes. </p>\n<p>Normal Use:</p>\n<pre><code>ps\n</code></pre>\n<p>For More Info</p>\n<pre><code>ps -f\n</code></pre>\n<p>For a particular process ID</p>\n<pre><code>ps &lt;process id&gt;\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654185800241_image.png\"></p>\n<p><strong>Fields described by ps are described as:</strong> </p>\n<ul>\n<li><strong>UID</strong>: User ID that this process belongs to (the person running it)</li>\n<li><strong>PID</strong>: Process ID</li>\n<li><strong>PPID</strong>: Parent process ID (the ID of the process that started it)</li>\n<li><strong>C</strong>: CPU utilization of process</li>\n<li><strong>STIME</strong>: Process start time</li>\n<li><strong>TTY</strong>: Terminal type associated with the process</li>\n<li><strong>TIME</strong>: CPU time is taken by the process</li>\n<li><strong>CMD</strong>: The command that started this process</li>\n</ul>\n<h1 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h1><ul>\n<li><code>kill</code> command in Linux, is a built-in command which is used to terminate processes manually.</li>\n<li>It helps in unwanted congestion or saturation of tasks.</li>\n</ul>\n<p><strong>Basic Syntax</strong></p>\n<pre><code>kill &lt;signal&gt; &lt;process id&gt;\n</code></pre>\n<p><code>**kill -l**</code> **:**To display all the available signals</p>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654186317333_image.png\"></p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><pre><code>kill -5 1234\nkill -SIGKILL 1234\n</code></pre>\n<h1 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a><code>top</code></h1><ul>\n<li>Displays all tasks presently running.</li>\n<li>It has a CLI for killing, sorting and suspending tasks</li>\n<li><code>htop</code> is an improved version of this software.</li>\n</ul>\n<p><strong>Usage</strong></p>\n<pre><code>top\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202140380_image.png\"></p>\n<pre><code>htop\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202325247_image.png\"></p>\n<p><code>**bashtop**</code></p>\n<ul>\n<li>bashtop is a resource monitor that shows usage and stats for processor,memory, disks, network and processes.<ul>\n<li>Easy to use, with a game inspired menu system.</li>\n<li>Function for showing detailed stats for selected process.</li>\n<li>Ability to filter processes.</li>\n<li>Easy switching between sorting options.</li>\n<li>Send SIGTERM, SIGKILL, SIGINT to selected process.</li>\n<li>UI menu for changing all config file options.</li>\n<li>Auto scaling graph for network usage.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654706380412_image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"FOSS\"><a href=\"#FOSS\" class=\"headerlink\" title=\"FOSS\"></a>FOSS</h1><p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201183185_371px-Richard_Stallman_at_LibrePlanet_2019.jpg\" alt=\"Richard Stallman\"></p>\n<h2 id=\"“Free-and-Open-Source-Software”\"><a href=\"#“Free-and-Open-Source-Software”\" class=\"headerlink\" title=\"“Free and Open Source Software”\"></a>“Free and Open Source Software”</h2><ul>\n<li>The freedom to run the program as you wish, for any purpose .</li>\n<li>The freedom to study how the program works, and change it so it does your computing as you wish . </li>\n<li>The freedom to redistribute copies so you can help others.</li>\n<li>The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this</li>\n</ul>\n<h1 id=\"GNU-GNU’s-Not-Unix\"><a href=\"#GNU-GNU’s-Not-Unix\" class=\"headerlink\" title=\"GNU - GNU’s Not Unix\"></a>GNU - GNU’s Not Unix</h1><p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654201894183_file.png\"></p>\n<h1 id=\"FOSS-vs-Proprietary-software\"><a href=\"#FOSS-vs-Proprietary-software\" class=\"headerlink\" title=\"FOSS vs Proprietary software?\"></a>FOSS vs Proprietary software?</h1><p>Propreitery soft.</p>\n<ul>\n<li>Costly</li>\n<li>Under control of the org</li>\n<li>ppl cant contribute</li>\n</ul>\n<h1 id=\"Process\"><a href=\"#Process\" class=\"headerlink\" title=\"Process\"></a>Process</h1><p>A program&#x2F;command when executed, a special instance is provided by the system to the process. This instance consists of all the services&#x2F;resources that may be utilized by the process under execution. </p>\n<ul>\n<li>Whenever a command is issued in Unix&#x2F;Linux, it creates&#x2F;starts a new process. For example, pwd when issued which is used to list the current directory location the user is in, a process starts.</li>\n<li>Through a 5 digit ID number Unix&#x2F;Linux keeps an account of the processes, this number is call process ID or PID. Each process in the system has a unique PID.</li>\n<li>Used up pid’s can be used in again for a newer process since all the possible combinations are used.</li>\n<li>At any point of time, no two processes with the same pid exist in the system because it is the pid that Unix uses to track each process.</li>\n</ul>\n<p><strong>Foreground Process :</strong> Every process when started runs in foreground by default, receives input from the keyboard, and sends output to the screen.  </p>\n<p><strong>Background Process:</strong> It runs in the background without keyboard input and waits till keyboard input is required. Thus, other processes can be done in parallel with the process running in the background since they do not have to wait for the previous process to be completed. </p>\n<h1 id=\"Types-of-process\"><a href=\"#Types-of-process\" class=\"headerlink\" title=\"Types of process\"></a>Types of process</h1><h1 id=\"Parent-Process\"><a href=\"#Parent-Process\" class=\"headerlink\" title=\"Parent Process\"></a>Parent Process</h1><p>All the processes in operating system are created when a process executes the fork() system call except the startup process. The process that used the fork() system call is the parent process. In other words, a parent process is one that creates a child process. A parent process may have multiple child processes but a child process only one parent process.<br>On the success of a fork() system call, the PID of the child process is returned to the parent process and 0 is returned to the child process. On the failure of a fork() system call, -1 is returned to the parent process and a child process is not created.</p>\n<h1 id=\"Child-Process\"><a href=\"#Child-Process\" class=\"headerlink\" title=\"Child Process\"></a>Child Process</h1><p>A child process is a process created by a parent process in operating system using a fork() system call. A child process may also be called a subprocess or a subtask.<br>A child process is created as its parent process’s copy and inherits most of its attributes. If a child process has no parent process, it was created directly by the kernel.<br>If a child process exits or is interrupted, then a SIGCHLD signal is send to the parent process.<br>A diagram that demonstrates parent and child process is given as follows −</p>\n<p><img src=\"http://www.it.uu.se/education/course/homepage/os/vt18/images/module-2/fork-wait-exit.png\" alt=\"How parent-child process works\"></p>\n<h1 id=\"Zombie-Process\"><a href=\"#Zombie-Process\" class=\"headerlink\" title=\"Zombie Process\"></a>Zombie Process</h1><p>A zombie process is a process whose execution is completed but it still has an entry in the process table. Zombie processes usually occur for child processes, as the parent process still needs to read its child’s exit status. Once this is done using the wait system call, the zombie process is eliminated from the process table. This is known as reaping the zombie process.</p>\n<p><img src=\"https://www.tutorialspoint.com/assets/questions/media/12233/Zombie%20Process%20in%20LInux.png\" alt=\"Zombie Process\"></p>\n<ul>\n<li>All the memory and resources allocated to a process are deallocated when the process terminates using the <code>exit()</code> system call. But the process’s entry in the process table is still available. This process is now a zombie process.</li>\n<li>The exit status of the zombie process zombie process can be read by the parent process using the <code>wait()</code> system call. After that, the zombie process is removed from the system. Then the process ID and the process table entry of the zombie process can be reused.</li>\n<li>If the parent process does not use the <code>wait()</code> system call, the zombie process is left in the process table. This creates a resource leak.</li>\n<li>If the parent process is not running anymore, then the presence of a zombie process indicates an operating system bug. This may not be a serious problem if there are a few zombie processes but under heavier loads, this can create issues for the system such as running out of process table entries.</li>\n<li>The zombie processes can be removed from the system by sending the <code>SIGCHLD</code> signal to the parent, using the kill command. If the zombie process is still not eliminated from the process table by the parent process, then the parent process is terminated if that is acceptable.</li>\n</ul>\n<p>We can see zombie processes if we type <code>ps -aux</code>.</p>\n<table>\n<thead>\n<tr>\n<th><strong>STAT</strong></th>\n<th><strong>Process State</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>D</strong></td>\n<td>uninterruptible sleep (usually IO)</td>\n</tr>\n<tr>\n<td><strong>R</strong></td>\n<td>running or runnable (on run queue)</td>\n</tr>\n<tr>\n<td><strong>S</strong></td>\n<td>interruptible sleep (waiting for an event to complete)</td>\n</tr>\n<tr>\n<td><strong>T</strong></td>\n<td>stopped, either by a job control signal or because it is being traced</td>\n</tr>\n<tr>\n<td><strong>X</strong></td>\n<td>dead (should never be seen)</td>\n</tr>\n<tr>\n<td><strong>Z</strong></td>\n<td>defunct (“zombie”) process, terminated but not reaped by its parent</td>\n</tr>\n<tr>\n<td><strong>&lt;</strong></td>\n<td>high-priority (not nice to other users)</td>\n</tr>\n<tr>\n<td><strong>N</strong></td>\n<td>low-priority (nice to other users)</td>\n</tr>\n<tr>\n<td><strong>L</strong></td>\n<td>has pages locked into memory (for real-time and custom IO)</td>\n</tr>\n<tr>\n<td><strong>s</strong></td>\n<td>is a session leader</td>\n</tr>\n<tr>\n<td><strong>l</strong></td>\n<td>is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</td>\n</tr>\n<tr>\n<td><strong>+</strong></td>\n<td>is in the foreground process group</td>\n</tr>\n</tbody></table>\n<h1 id=\"Orphan-Process\"><a href=\"#Orphan-Process\" class=\"headerlink\" title=\"Orphan Process\"></a>Orphan Process</h1><ul>\n<li>Orphan processes are those processes that are still running even though their parent process has terminated or finished. A process can be orphaned intentionally or unintentionally.</li>\n<li>An intentionally orphaned process runs in the background without any manual support. This is usually done to start an indefinitely running service or to complete a long-running job without user attention.</li>\n<li>An unintentionally orphaned process is created when its parent process crashes or terminates. Unintentional orphan processes can be avoided using the process group mechanism.</li>\n</ul>\n<h1 id=\"Daemon-Process\"><a href=\"#Daemon-Process\" class=\"headerlink\" title=\"Daemon Process\"></a>Daemon Process</h1><p>A daemon process is a background process that is not under the direct control of the user. This process is usually started when the system is started and is terminated with the system shut down.<br>Usually the parent process of the daemon process is the init process. This is because the init process usually adopts the daemon process after the parent process forks the daemon process and terminates.<br>The daemon process names normally end with a d. Some of the examples of daemon processes in Unix are −</p>\n<ul>\n<li><strong>crond</strong></li>\n<li>This is a job scheduler that runs jobs in the background.</li>\n<li><strong>syslogd</strong></li>\n<li>This is the system logger that implements the system logging facility and collects system messages.</li>\n<li><strong>httpd</strong></li>\n<li>This is the web server daemon process that handles the Hypertext Transfer Protocol.</li>\n<li><strong>dhcpd</strong></li>\n<li>This daemon configures the TCP&#x2F;IP information for users dynamically.</li>\n</ul>\n<h1 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h1><p>ps (Process status) can be used to see&#x2F;list all the running processes. </p>\n<p>Normal Use:</p>\n<pre><code>ps\n</code></pre>\n<p>For More Info</p>\n<pre><code>ps -f\n</code></pre>\n<p>For a particular process ID</p>\n<pre><code>ps &lt;process id&gt;\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654185800241_image.png\"></p>\n<p><strong>Fields described by ps are described as:</strong> </p>\n<ul>\n<li><strong>UID</strong>: User ID that this process belongs to (the person running it)</li>\n<li><strong>PID</strong>: Process ID</li>\n<li><strong>PPID</strong>: Parent process ID (the ID of the process that started it)</li>\n<li><strong>C</strong>: CPU utilization of process</li>\n<li><strong>STIME</strong>: Process start time</li>\n<li><strong>TTY</strong>: Terminal type associated with the process</li>\n<li><strong>TIME</strong>: CPU time is taken by the process</li>\n<li><strong>CMD</strong>: The command that started this process</li>\n</ul>\n<h1 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h1><ul>\n<li><code>kill</code> command in Linux, is a built-in command which is used to terminate processes manually.</li>\n<li>It helps in unwanted congestion or saturation of tasks.</li>\n</ul>\n<p><strong>Basic Syntax</strong></p>\n<pre><code>kill &lt;signal&gt; &lt;process id&gt;\n</code></pre>\n<p><code>**kill -l**</code> **:**To display all the available signals</p>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654186317333_image.png\"></p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><pre><code>kill -5 1234\nkill -SIGKILL 1234\n</code></pre>\n<h1 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a><code>top</code></h1><ul>\n<li>Displays all tasks presently running.</li>\n<li>It has a CLI for killing, sorting and suspending tasks</li>\n<li><code>htop</code> is an improved version of this software.</li>\n</ul>\n<p><strong>Usage</strong></p>\n<pre><code>top\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202140380_image.png\"></p>\n<pre><code>htop\n</code></pre>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654202325247_image.png\"></p>\n<p><code>**bashtop**</code></p>\n<ul>\n<li>bashtop is a resource monitor that shows usage and stats for processor,memory, disks, network and processes.<ul>\n<li>Easy to use, with a game inspired menu system.</li>\n<li>Function for showing detailed stats for selected process.</li>\n<li>Ability to filter processes.</li>\n<li>Easy switching between sorting options.</li>\n<li>Send SIGTERM, SIGKILL, SIGINT to selected process.</li>\n<li>UI menu for changing all config file options.</li>\n<li>Auto scaling graph for network usage.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://paper-attachments.dropbox.com/s_7F2492607B71714A428607E3287D6493F19F9B88906C055C4E199BFBDF802B26_1654706380412_image.png\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}